@[TOC]
# 题目
[点击查看力扣原题](https://leetcode-cn.com/problems/w3tCBm/)
# 解题思路
## 常规解法
根据前人的经验 :  表达式"i&(i-1)"可使得整数i的二进制表示中最右边的第一个1转化成0；
开启嵌套的两个for循环，记录1的个数。
第一个循环： 遍历n个数字
第二个循环： 重复对i做算法**（i&（i-1）**运算，直到i为0，累计操作次数。
```
   public int[] countBit(int n) {
        int[] result = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            //计算整数i的二进制表示中1的个数
            int j = i;
            while (j != 0) {
                j = j & (j - 1);
                result[i] += 1;
            }
        }
        return result;
    }
```
时间复杂度：O（k * n）
## 最佳解法
**位运算 + 动态规划**
考察的知识点：
- 位运算 ：取余和除以2对应的位运算
- 动态规划：推导子问题结果的关系，来建立转移方程，

- 具体步骤
  问题转换成子问题:
  遍历整数n，依次统计整数i的二进制为1的个数。**转化成子问题：求整数i二进制中1的个数。**
  逐步推导，总结规律：

| i |  二进制 | 1的个数 |
|  ----  | ----  | ----|
| 1 | 1|  1|
|2|10| 1|
|3|11|2|
|4|100|1|
|5|101|2|
|6|110|2|
|7|111|3|
|8|1000|1|
可以看出，整数i的二进制中1的个数，把分i两种情况考虑：偶数 i和奇数 i：
- 偶数
  i的二进制1个数 =  i/2的二进制1个数. 即result[6] = result[3] ;
- 奇数
  i的二进制1个数 = i/2的二进制1个数 + 1。 即result[7] =result[3] + 1；

根据上面的推导过程分析。我们可以得到**状态转移方程**：
result[i] = result[i / 2] + （i % 2）;
用**位运算**进一步优化：
result[i] = result[i >> 1] + (i & 1);
# 代码

```java
class Solution {
    public int[] countBits(int n) {
        int[] result = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            //计算整数i的二进制表示中：1的个数。
            result[i] = result[i >> 1] + (i & 1);
        }
        return result;
    }
}
```